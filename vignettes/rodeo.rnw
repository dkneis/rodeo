\documentclass[times,onecolumn]{article}

\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{lineno}

% Additional packages
\usepackage[american]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{currfile}
\usepackage{url}
\usepackage{rotfloat}
\usepackage{xcolor}
\usepackage{framed}
\usepackage{listings}
\usepackage{comment}
\usepackage{verbatim}
\usepackage{mdframed}
\usepackage{calc}

\usepackage{Sweave}
%\SweaveSyntax{SweaveSyntaxLatex}

\usepackage{caption}
\DeclareCaptionType[fileext=loc]{listing}

\definecolor{shadecolor}{gray}{0.9}

\usepackage{hyperref}
\hypersetup{
    colorlinks=true, % make the links colored
    linkcolor=blue, % color TOC links in blue
    urlcolor=red, % color URLs in red
    linktoc=all % 'all' will create links for everything in the TOC
}

%\VignetteIndexEntry{A code generator for ODE-based models in R}

\begin{document}

% Turn prompts off in R code
<<echo=FALSE>>=
options(continue=" ", prompt=" ")
@

\lstset{basicstyle=\ttfamily\small,
  commentstyle=\textsl,
  showstringspaces=false,
  frame=shadowbox,
  rulesepcolor=\color{black},
  rangebeginprefix= \#\#TexBegin\{,
  rangebeginsuffix= \},
  rangeendprefix= \#\#TexEnd\{,
  rangeendsuffix= \},
  includerangemarker= false,
  numbers=left,
  numberstyle=\color{white}\ttfamily\tiny,
  stepnumber=1,
  numbersep=3mm,
  morecomment=[is]{\#\#----------------------------------------BeginHide}
    {\#\#----------------------------------------EndHide}
}

\newcommand{\software}[1]{\texttt{#1}}

\newcommand{\figdir}{.}
\newcommand{\sect}{Section}
\newcommand{\sects}{Sections}

\newcommand{\oxygen}{O\ensuremath{_{2}}}
\newcommand{\OM}{\textrm{OM}}
\newcommand{\DO}{\textrm{DO}}

\newcommand{\todo}[1]{\textcolor{red}{\textbf{#1}}}

\newcommand{\grey}[1]{\textcolor{gray}{#1}}

\title{Vignette for \software{R} package \software{rodeo}}

\author{David Kneis, david.kneis [at] tu-dresden.de}

\date{\today}

\maketitle

\tableofcontents

\section{When to use this package}

The \software{rodeo} package facilitates the implementation of ODE-based models. These are models that describe the dynamics of a set of $n$ state variables by integrating a set of $n$  ordinary differential equations. The package is particularly useful in conjunction with the \software{deSolve} package (\url{http://cran.r-project.org/package=deSolve}) providing numerical solvers for initial value problems. The advantages from using \software{rodeo} are:

\begin{itemize}
\item Models are defined using plain tabular text files or spreadsheets. Thus, the model is formulated independent from source code. This facilitates documentation, portability, and re-use.
\item You are forced to provide the model in stoichiometry matrix notation (see \url{http://en.wikipedia.org/wiki/Petersen_matrix}). Although this is a restriction, it is a very useful one and benefit is almost guaranteed.
\item Owing to the matrix notation, redundant terms are eliminated from the differential equations. This contributes to comprehensibility and increases computational efficiency. The stoichiometry matrix can also be visualized to better communicate the model to users or non-modelers.
\item \software{rodeo} provides a code generator which supports \software{R} and \software{Fortran} as target languages. Using compiled \software{Fortran} can speed up numerical integration by 1 or 2 orders of magnitude (compared to plain \software{R}).
\item The generated source code is applicable to an arbitrary number of boxes (control volumes). This allows even partial differential equations (e.~g. reactive transport problems) to be tackled by means of semi-discretization  (see \url{http://en.wikipedia.org/wiki/Method_of_lines}).
\end{itemize}

\section{Example problem}
The functioning of the package is best illustrated by an example. In this document, we consider a continuous flow stirred tank reactor (CFSTR) containing a degradable organic matter (concentration \verb|c_z|) and dissolved oxygen, \verb|c_do| (Fig.~\ref{fig:reactor}). Due to mixing, the reactors contents is spatially homogeneous, hence the concentrations are scalars. Changes in concentrations are triggered by
\begin{enumerate}
\item the loads in the reactor's inflow,
\item aerobic degradation of the organic matter (1st order) which consumes dissolved oxygen,
\item exchange of oxygen with the atmosphere.
\end{enumerate}

Some specific aspects of the model are as follows:
\begin{itemize}
\item The dependence of aerobic degradation on available oxygen is described with a Monod term (Michaelis-Menten model).
\item The rate of oxygen exchange between water and atmosphere is described as an empirical function of water depth and wind speed.
\item The model does \emph{not} assume steady flow conditions, hence the volume of the reactor is a state variable too.
\end{itemize}

\begin{figure}
\centering
\includegraphics[width=0.5\textwidth]{reactor.pdf}
\caption{Sketch of considered system. \label{fig:reactor}}
\end{figure}

Using \software{rodeo}, the model can be described using just tabular text files (Tables~\ref{tab:identifiers} -- \ref{tab:stoichiometry}). These files are shipped with the package and can be loaded with \software{R}'s \verb|data| method.

\begin{table}
\caption{Declaration of identifiers (data set 'exampleIdentifiers'). The type column indicates whether an item is a state variable (v), parameter (p), or function (f). \label{tab:identifiers}}
\begin{shaded}
\begin{small}
<<echo=FALSE>>=
library(rodeo, quietly=TRUE)
data(exampleIdentifiers)
print(format(exampleIdentifiers, justify="right"), row.names=FALSE)
@
\end{small}
\end{shaded}
\end{table}

\begin{table}
\caption{Specification of processes (data set 'exampleProcesses'). \label{tab:processes}}
\begin{shaded}
\begin{small}
<<echo=FALSE>>=
library(rodeo, quietly=TRUE)
data(exampleProcesses)
print(format(exampleProcesses, justify="right"), row.names=FALSE)
@
\end{small}
\end{shaded}
\end{table}

\begin{table}
\caption{Specification of stoichiometric factors (data set 'exampleStoichiometry'). \label{tab:stoichiometry}}
\begin{shaded}
\begin{small}
<<echo=FALSE>>=
library(rodeo, quietly=TRUE)
data(exampleStoichiometry)
print(format(exampleStoichiometry, justify="right"), row.names=FALSE)
@
\end{small}
\end{shaded}
\end{table}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\clearpage
\section{Basic use}

\subsection{Creating and inspecting a model object}

We start by creating a new object with \verb|new|. This requires us to supply the name of the class as well as a set of data frames for initialization.

<<echo=TRUE>>=
library(rodeo, quietly=TRUE)

# Load sample data frames (contents shown above)
data(exampleIdentifiers, exampleProcesses, exampleStoichiometry)

# Instantiate new object
model= new("rodeo", vars=subset(exampleIdentifiers,type=="v"),
  pars=subset(exampleIdentifiers,type=="p"),
  funs=subset(exampleIdentifiers,type=="f"),
  pros=exampleProcesses, stoi=exampleStoichiometry)
@

To inspect the object's contents, we can use the following:

<<echo=TRUE, eval=FALSE>>=
# Built-in method
model$show()

# Show stoichiometry information as a matrix
print(model$stoichiometry())
@

\subsection{Defining functions and supplying data}

In order to work with the object, we need to define functions that are referenced in the model's mathematical expressions. This includes the forcings which are functions of a special argument with the reserved name 'time'. See Sect.~\ref{sec:advanced:forcings} for details.

<<echo=TRUE, eval=TRUE>>=
# 'normal' functions
O2sat= function(t) {
  14.652 - 0.41022*t + 0.007991*t^2 - 0.000077774*t^3
}
ka= function(u, d) {
  (0.728*sqrt(u) - 0.317*u + 0.0372*u^2) / d / 86400
}
monod= function(s,h) {
  s / (s + h)
}
@

<<echo=TRUE, eval=TRUE>>=
# forcings are functions of special variable 'time'
c_z_in= function(seconds) {
  0.1 * seconds/(7*86400 + seconds)
}
c_do_in= function(seconds) {
  10.  # taken as constant
}
@

We also need to set the values of parameters and state variables (initial values). We first define both parameters and initial values as lists. These lists are then coerced into named vectors using the dedicated methods \verb|arrangePars| and \verb|arrangeVars|. Use of these methods guarantees that the vector elements appear in proper order. Proper order is essential when the vector elements are accessed \emph{by position} rather than \emph{by name}.

<<setDataSingleBox, echo=TRUE, eval=TRUE>>=
pars= list(kd=5.78e-7, h_do=0.5, s_do_z=2.76, wind=1, depth=2,
 temp=20, q_in=1, q_ex=1)
vars= list(c_z=1, c_do=9.022, v=1.e6)
p= model$arrangePars(pars)
v= model$arrangeVars(vars)
@

\subsection{Computing the stoichiometry matrix}

Having defined all functions and having set the values of variables and parameters, one can compute the stoichiometric factors. In general, explicitly computing these factors is not necessary, it may be helpful in debugging however. To do so, the \verb|stoichiometry| method needs to be supplied with values of all state variables, parameters, as well as a time value (in the case of non-autonomous models).

<<echo=TRUE, eval=TRUE>>=
m= model$stoichiometry(c(v, p, time=0))
print(signif(m, 3))
@

The stoichiometry matrix is also a good means to communicate a model because it shows the interactions between processes and variables in a concise way. How the stoichiometry matrix can be visualized graphically is demonstrated in Sect.~\ref{sec:advanced:doc:stoi}.

\subsection{Translating the model into source code}

In order to use the model for simulation, we need to transfer it into source code. This is also known as \emph{code generation}. Specifically, we want the code generator to create a function that returns the derivatives of the state variables with respect to time. In addition to the derivatives, the generated function also returns the values of all process rates (as diagnostic variables).

After generating the code, we need to make it executable. In \software{R}, we can use a combination of \verb|eval| and \verb|parse|. Alternatively, the generated code could be for loaded with \verb|source| after exporting it to a file (e.g. using \verb|write|). The latter method is needed if one wants to inspect the generated code (or even modify it, which rarely makes sense).

<<echo=TRUE, eval=TRUE>>==
code= model$generate(name="derivs",lang="r")
derivs= eval(parse(text=code))
@

\subsection{Solving the ODE system} \label{sec:solve-R}

We are now ready to compute the evolution of the state variables over time by means of numerical integration. At this point, the proper order of the elements in the vectors \verb|v| and \verb|p| is essential since the generated function code uses \emph{by-index} access! Therefore, \verb|v| and \verb|p| should always be set by calls to the \verb|arrangeVars| and \verb|arrangePars| method, respectively.

In addition to the dynamics of the state variables, we also get the dynamics of the process rates.

<<echo=TRUE, eval=TRUE, fig=TRUE>>=
library(deSolve)
t= seq(0, 30*86400, 3600)
out= ode(y=v, times=t, func=derivs, parms=p, NLVL=1)
layout(matrix(1:9, ncol=3, byrow=TRUE))
plot(out, mfrow=NULL)
layout(1)
@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\clearpage
\section{Advanced topics} \label{sec:advanced}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Spatially distributed systems (multi-box models)} \label{sec:advanced:multibox}

A zero-dimensional case (single reactor) has been considered so far. We will now extend the model for multiple spatial levels, i.~e. for a collection of (isolated) reactors.

First, we need to provide vectors (instead of scalars) for one variable and one parameter, at least. Variables and parameters with scalar values will be replicated to vectors of the required length. In the example, we initialize every modeled reactor with a different concentration of organic matter.

Second, we need to pass the actual number of reactors to the derivatives function in the \verb!NLVL! argument.

<<setDataMultiBox, echo=FALSE, eval=FALSE>>=
nbox= 3
pars= list(kd=rep(5.78e-7, nbox), h_do=0.5, s_do_z=2.76, wind=1,
  depth=2, temp=20, q_in=1, q_ex=1)
vars= list(c_z=seq(from=0, to=50, length.out=nbox), c_do=9.022,
  v=1.e6)
p= model$arrangePars(pars)
v= model$arrangeVars(vars)
@
<<echo=TRUE, eval=TRUE, fig=TRUE, width=6, height=2.5>>=
<<setDataMultiBox>>
out= ode(y=v, times=t, func=derivs, parms=p, NLVL=nbox)
layout(matrix(1:nbox, nrow=1))
plot(out, which=paste("c_do",1:nbox,sep="."), mfrow=NULL)
@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Increasing performance by means of \software{Fortran}} \label{sec:advanced:fortran}

Real-world models usually consist of many and lengthy mathematical expressions. Also, depending on the studied problem, the ODE solver may need to use (very) short time steps. Then, computation times become of serious concern. In those time-critical cases, it is recommended to generate source code for a fast, compilable language rather than for (slower) \software{R}. The compilable language supported by \software{rodeo} is \software{Fortran}.

To generate code to compute the state variables' derivatives in \software{Fortran}, one would use:

<<echo=TRUE, eval=TRUE>>=
code= model$generate(name="derivs",lang="f95")
# Optionally display generated code
#cat(code)
@

The generated \software{Fortran} subroutine with assumed name \verb|derivs| has a simple, quite universal interface

\begin{verbatim}
subroutine derivs(time, var, par, NLVL, dydt, pro)
\end{verbatim}

In order to use the numerical solvers from the packages \url{http://cran.r-project.org/package=deSolve} or \url{http://cran.r-project.org/package=rootSolve}, however, a different interface is required

\begin{verbatim}
subroutine derivs (neq, t, y, ydot, yout, ip)
\end{verbatim}

and an additional subroutine for parameter initialization (\verb|initmod|) must to be supplied as well (see the \software{deSolve} vignette \url{http://cran.r-project.org/web/packages/deSolve/vignettes/compiledCode.pdf}, page 6). Consequently, a suitable wrapper code must be written.

In order to make the use of \software{Fortran} as simple as possible, the \software{rodeo} package provides a high-level class method \verb|compile| that combines

\begin{enumerate}
\item generation of the basic \software{Fortran} code via the \verb|generate| method (see above),
\item generation of wrapper code for compatibility with \software{deSolve} and \software{rootSolve},
\item compilation of all \software{Fortran} sources into a shared library using the \verb|R CMD SHLIB| command,
\item clean-up of any intermediate files from compilation.
\end{enumerate}

The \verb|compile| method takes two arguments. First comes the name of a file holding the \software{Fortran} implementation of functions being referenced in the particular model's mathematical expressions (consult Sect.~\ref{sec:fortranFunctions} for guidelines). This can actually be a vector of file names if the source code is split. The second argument \verb|NLVL| is an integer, specifying the desired number of spatial levels (see Sect.~\ref{sec:advanced:multibox}; default is \verb|NLVL=1|).

<<echo=TRUE, eval=TRUE>>=
lib= model$compile(fileFun="functionsCode.f95", NLVL=nbox)
@

The return value of \verb|compile| is a vector of character strings holding the name of the generated library (in element \verb|libName|), the full file path of the library (in element \verb|libFile|) as well as the name of the callable subroutine within that library (in element \verb|libFunc|).

A suitable \software{Fortran} implementation of the functions used in the example (contents of file 'functionsCode.f95') is shown below. Note that all the functions are collected in a single \software{Fortran} module with implicit typing turned off. The name of this module (\verb|functions|) is mandatory and cannot be changed. Note that a module can import other modules which helps to structure the source code. Also note that the user-supplied source files need to reside in directories with write-access to allow the creation of intermediate files during compilation.

\begin{shaded}
<<echo=FALSE, eval=TRUE>>=
file_ffuns= "functionsCode.f95"
text= readLines(file_ffuns, n=-1L, ok=TRUE, warn=TRUE, encoding="unknown", skipNul=FALSE)
text= paste(text,"\n")
cat(text)
@
\end{shaded}

We are now prepared to load the shared library and run the simulation based on the \software{Fortran} code. Note the additional arguments \verb|dllname|, \verb|initfunc|, and \verb|nout| being passed to the numerical solver (open the help page for \verb|lsoda| to see the documentation for them). Setting a wrong value for \verb|nout| easily makes \software{R} crash.

Also note that, in contrast to the R-based version (see Sect.~\ref{sec:solve-R}), the number of reactors (boxes) is not passed to the solver as an additional parameter \verb|NLVL|. In the case of \software{Fortran}, this number is rather supplied to the \verb|compile| method (see above) and it is thus hard-coded in the compiled code.

<<echo=TRUE, eval=TRUE, fig=TRUE, width=6, height=2.5>>=
<<setDataMultiBox>>
dyn.load(lib["libFile"])
out= ode(y=v, times=t, func=lib["libFunc"], parms=p,
  dllname=lib["libName"], initfunc="initmod", nout=model$lenPros()*nbox)
layout(matrix(1:nbox, nrow=1))
dyn.unload(lib["libFile"])
plot(out, which=paste("c_do",1:nbox,sep="."), mfrow=NULL)
@

<<echo=FALSE, eval=TRUE>>=
# Clean up dll file
invisible(file.remove(lib["libFile"]))
@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Forcings (time-varying parameters)} \label{sec:advanced:forcings}

\subsubsection{Two alternative options}
In general, there are two options for dealing with time-variable forcings:

\paragraph{functions-of-time:} In this approach one needs to define the forcings as functions of a single argument representing time. In \software{rodeo} this argument must have the reserved name \verb|time|. Use of this approach is most convenient if the forcings are easily described as parametric functions of time (e.g. seasonal change of solar radiation). It can also be used with tabulated time series data, but this requires some extra coding. In any case, it is essential for rescrict the integration step size of the solver (e.g. using the \verb|hmax| argument of \verb|deSolve::lsoda|) so that short-term variations in the forcings cannot be 'missed'.
 
\paragraph{stop-and-go:} In this approach forcings are implemented as normal parameters. To allow for their variation in time, the ODE solver is interrupted every time when the forcing data change. The solver is then re-started with the updated parameters (i.e. forcing data) using the states computed in the previous call as initial values. Hence, the calls to the ODE solver must be embedded within a time-loop. With this approach, setting a limit on the solver's integration step size (through argument \verb|hmax|) is not required since the solver is interrupted at the 'critical times' anyway.

In real-world applications, the 'stop-and-go' approach is often simpler to use and the overhead due to interruption and re-start of the solvers seems to be rather small. It also facilitates the generation of useful traceback information in case of exceptions (e.g. due to corrupt time series data).

\subsubsection{The 'functions-of-time' approach with \software{Fortran} models}

This section demonstrates how the 'functions-of-time' approach can be used in \software{Fortran}-based models assuming that information on forcings is stored in delimited text files. Such files can be created, for example, with any spreadsheet software, data base system, or \software{R}. Assume that we have time series of two meteorological variables exported to a text file 'meteo.txt':

<<echo=TRUE, eval=TRUE>>=
dat= data.frame(time=1:10, temp=round(rnorm(n=10, mean=20, sd=3)),
  humid=round(runif(10)*100))
write.table(x=dat, file="meteo.txt", col.names=TRUE,
  row.names=FALSE, sep="\t", quote=FALSE)
print(dat)
@

We can now call \verb|forcingFunctions| to generate the  appropriate forcing function in \software{Fortran}. In this example, we request linear interpolation via the method's \verb|mode| argument.

<<echo=TRUE, eval=TRUE>>=
dat= data.frame(name=c("temp","humid"),
  column=c("temp","humid"), file="meteo.txt", mode=-1, default=FALSE)
code= forcingFunctions(dat)
write(x=code, file="forc.f95")
# Optionally inspect generated code
# cat(code)
@

In order to use the generated code, it is necessary to
\begin{enumerate}
\item write it to disk (e.~g. using \verb|write| as above),
\item declare all forcings as functions in \software{rodeo}'s respective input table,
\item insert the statement \verb|use forcings| at the top (e.~g. line 2) of the \software{Fortran} module \verb|functions|,
\item pass the generated file to the compiler along with all other \software{Fortran} source files.
\end{enumerate}

The following \software{Fortran} code demonstrates how the user-defined forcings can be tested/debugged outside of the \software{rodeo} environment. The shown utility program can be compiled, for example, using a command like

\medskip
\verb|gfortran <generated_module_file> <file_with_program> -o test|

\medskip
Note that the subroutines \verb|rwarn| and \verb|rexit| are available automatically if the code is used to build a shared library with \verb|R CMD SHLIB|, i.~e. the subroutines must not be defined then.

\begin{shaded}
<<eval=TRUE, echo=FALSE>>=
text= readLines("fortranForcingsTest.f95", n=-1L, ok=TRUE, warn=TRUE, encoding="unknown", skipNul=FALSE)
text= paste(text,"\n")
cat(text)
@
\end{shaded}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Generating model documentation} \label{sec:advanced:doc}

\subsubsection{Exporting formatted tables} \label{sec:advanced:doc:tables}

One can use e.g. \verb|exportDF| to export the object's basic information in a format which is suitable for inclusion in HTML or \LaTeX{} documents. The code section

<<exportTex, echo=TRUE, eval=FALSE>>=
# Select columns to export
df= model$getVars()[,c("tex","unit","description")]
# Define formatting functions
bold= function(x){paste0("\\textbf{",x,"}")}
mathmode= function(x) {paste0("$",x,"$")}
# Export
tex= exportDF(x=df, tex=TRUE,
  colnames=c(tex="symbol"),
  funHead=setNames(replicate(ncol(df),bold),names(df)),
  funCell=list(tex=mathmode)
)
cat(tex)
@

generates the following \LaTeX{} code

\begin{shaded}
<<echo=FALSE, eval=TRUE>>=
<<exportTex>>
@
\end{shaded}

holding tabular information on the model's state variables. To include the result in a document one needs to write the generated \LaTeX{} code to a file for import with either the \verb|input| or \verb|include| directive. Things are even simpler if the \software{Sweave} pre-processor is used (as in the case of this vignette file). The above \software{R} code can then be embedded in the \LaTeX{} code between the special markers \verb|<<echo=FALSE, results=tex>>=| and \verb|@| resulting in the following output.

\bigskip
\begin{center}
<<echo=FALSE, results=tex>>=
<<exportTex>>
@
\end{center}

\bigskip
Alternatively, a \software{markdown} compatible dataframe can be generated and used with the \software{knitr} function \verb|kable|. This will work with html, pdf or even Word (.docx) output. The following code section would create a table of the model's state variables (output not shown).

<<exportMarkdown, echo=TRUE, eval=FALSE>>=
to_markdown= function(dat, which_cols){
  cols= which(names(dat) %in% which_cols)
  for(i in cols){
    dat[, i]= ifelse(dat[, i] != "", paste0("$", dat[, i], "$"), "")
    }
  return(dat)
} 

ids= model$getVars()[,c("tex", "unit", "description")]
names(ids)= c("Symbol", "Unit", "Description")
kable(to_markdown(ids, which_cols=c("Symbol")),
  caption = "State variables")
@

% Commented out to get rid of the dependence on the knitr package
%\begin{shaded}
%<<echo=FALSE, eval=FALSE>>=
%<<exportMarkdown>>
%@
%\end{shaded}

Thanks to Andrew Dolman for the latter example.

\subsubsection{Visualizing the stoichiometry matrix} \label{sec:advanced:doc:stoi}

A graphical representation of the stoichiometry matrix is often a good means to communicate a model. To create such a graphics, one typically wants to replace the stoichiometry factors' numeric values by symbols encoding their sign only.

\paragraph{Option 1: Plain R graphics}
One can use the class method \verb|plotStoichiometry| to visualize the matrix using standard R graphic facilities as demonstrated below. In practice, one needs to fiddle around a bit with the dimensions of the plot and the font size to get an acceptable scaling of symbols and text. Also, it is hardly possible to nicely display row and column names containing special things like sub- or superscripts.

<<echo=TRUE, eval=TRUE, fig=TRUE, width=1.7, height=2.2>>=
<<setDataSingleBox>>
model$plotStoichiometry(values=c(v, p, time=0), cex=0.3)
@

\paragraph{Option 2: TEX}
The following example generates suitable code for inclusion in \LaTeX{} documents.

<<echo=TRUE, eval=TRUE>>=
<<setDataSingleBox>>
signsymbol= function(x) {
  if (as.numeric(x) > 0) return("\\textcolor{orange}{$\\blacktriangle$}")
  if (as.numeric(x) < 0) return("\\textcolor{cyan}{$\\blacktriangledown$}")
  return("")
}
rot90= function(x) { paste0("\\rotatebox{90}
  {$",gsub(pattern="*", replacement="\\cdot ", x=x, fixed=TRUE),"$}") }
m= model$stoichiometry(c(v, p, time=0))
tbl= cbind(data.frame(process=rownames(m), stringsAsFactors=FALSE),
  as.data.frame(m))
tex= exportDF(x=tbl, tex=TRUE,
  colnames= setNames(c("",model$getVars()$tex[match(colnames(m),
    model$getVars()$name)]), names(tbl)),
  funHead= setNames(replicate(ncol(m),rot90), colnames(m)),
  funCell= setNames(replicate(ncol(m),signsymbol), colnames(m)),
  lines=TRUE
)
tex= paste0("%\n% THIS IS A GENERATED FILE\n%\n", tex)
# write(tex, file="/home/dkneis/temp/stoichiometry.tex")
@

The contents of the variable \verb|tex| must be written to a text file and this file is then imported in \LaTeX{} with the \verb|input| directive. The result looks as follows:

<<echo=FALSE, eval=TRUE>>=
write(tex, file="./stoiGraphics.tex")
@
\begin{center}
\input{./stoiGraphics.tex}
\end{center}

\paragraph{Option 3: HTML}

The following example generates suitable code for inclusion in HTML documents.

<<echo=TRUE, eval=TRUE>>=
signsymbol= function(x) {
  if (as.numeric(x) > 0) return("&#9651;")
  if (as.numeric(x) < 0) return("&#9661;")
  return("")
}
m= model$stoichiometry(c(v, p, time=0))
tbl= cbind(data.frame(process=rownames(m), stringsAsFactors=FALSE),
  as.data.frame(m))
html= exportDF(x=tbl, tex=FALSE,
  colnames= setNames(c("Process",model$getVars()$html[match(colnames(m),
    model$getVars()$name)]), names(tbl)),
  funCell= setNames(replicate(ncol(m),signsymbol), colnames(m))
)
html= paste("<html>", html, "</html>", sep="\n")
# write(html, file="/home/dkneis/temp/stoichiometry.html")
@

To test this, one needs to write the contents of the variable \verb|html| to a text file and open that file in a web browser. In some cases, automatic conversion of the generated HTML into true graphics formats may be possible, e.~g. using auxiliary tools like \software{html2ps} and \software{convert} (on Linux systems).

\paragraph{Option 4: Markdown}

A \software{markdown} compatible can be generated with the \software{knitr} function \verb|kable| as shown below (contributed by Andrew Dolman; output not displayed).

<<stoiMarkdown, echo=TRUE, eval=FALSE>>=
signsymbol= function(x) {
  if (as.numeric(x) > 0) return("$\\blacktriangle$")
  if (as.numeric(x) < 0) return("$\\blacktriangledown$")
  return("")
}
stoi_mat= model$stoichiometry(c(v, p, time=0))
stoi_mat= data.frame(apply(stoi_mat, MARGIN = c(1, 2), signsymbol))
stoi_mat= setNames(stoi_mat, paste0("$",     
  model$getVars()$tex[match(colnames(stoi_mat),
  model$getVars()$name)], "$"))
stoi_mat= cbind(Process=rownames(stoi_mat), stoi_mat)

kable(stoi_mat, row.names= FALSE, caption= "Stoichiometric matrix")
@

% Commented out to get rid of the dependence on the knitr package
%\begin{shaded}
%\begin{small}
%<<echo=FALSE, eval=TRUE>>=
%<<stoiMarkdown>>
%@
%\end{small}
%\end{shaded}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Writing \software{rodeo}-compatible \software{Fortran} functions} \label{sec:fortranFunctions}

\subsection{Reference example}

As a reference, the following example code can be used which declares a function of two arguments. Comments have been added to explain the individual statements. In \software{Fortran}, comments are generally initiated with the exclamation mark (!). They may appear right after statements or on separate lines.

\begin{shaded}
\begin{small}
\begin{verbatim}
1  double precision function FUNCNAME (ARG1, ARG2) ! declare the function
2  implicit none                                   ! force declarations
3  double precision, intent(in):: ARG1, ARG2       ! declare arguments
4  double precision:: LOCAL                        ! declare local var.
5  double precision, parameter:: CONST=1.d0        ! declare local const.
6  LOCAL= ARG1 * CONST + ARG2                      ! local computation(s)
7  FUNCNAME= LOCAL                                 ! set return value
8  end function                                    ! closes the function
\end{verbatim}
\end{small}
\end{shaded}

For compatibility with \software{rodeo}, the function result must be a scalar of type \verb|double precision| (a floating point number of typically 8 byte). There are several ways to achieve this but the simplest and recommended syntax is put the type declaration \verb|double precision| right before the function's name (line 1). Then, the return value must be set by an assignment to the function's name (line 7). This is best done at a single location in the body code, typically at the very end.

It is a good habit to always put \verb|implicit none| in the first line of the function body (line 2). This is to disable so-called implicit typing (a rather dangerous technique of automatic data type assignment). With this statement, all arguments (line 3) and local variables or constants (lines 4 and 5) need to be explicitly declared. The repetition of the argument's names in lines 1 and 3 may be a bit annoying (but one can use copy and paste). All declarations need to be made at the top of the function's body (right after the \verb|implicit none|) before any other statements.

In \software{Fortran}, identifier names are not case-sensitive (as opposed to \software{R}). This applies to the name of the function itself as well as to the names of arguments and local variables or parameters.

Note: It is actually sufficient to use the \verb|implicit none| statement at the beginning of the module that contains all function declarations (see example in Sect.~\ref{sec:advanced:fortran}). Repetition of the statement in the individual functions does not do any harm, however. 

\subsection{Common pitfalls}

\subsubsection{Double precision variables and constants}

\software{Fortran} has several types to represent floating point numbers that vary in precision but \software{rodeo} generally uses the type \verb|double precision|. Thus, any local variables and parameters should also be declared as \verb|double precision|. To declare a numeric constant of this type, e.~g. 'pi', one needs to use the syntax \verb|3.1415d0|, i.~e. the conventional 'e' in scientific notation is replaced by 'd'. An alternative but less portable syntax exists but it is not mentioned here.

\begin{shaded}
\begin{small}
\begin{verbatim}
double precision, parameter:: pi= 3.1415d0, e= 2.7183d0   ! math constants 
double precision, parameter:: kilograms_per_gram = 1.d-3  ! 1/1000
double precision, parameter:: distance_to_moon = 3.844d+5 ! 384400 km
\end{verbatim}
\end{small}
\end{shaded}

Note the \verb|parameter| keyword used to inform the compiler that the declared item(s) are constants rather than variables.

\subsubsection{Integers in numeric expressions}

It is recommended to avoid integers in arithmetic expressions as the result may be unexpected. Use \verb|double precision| constants instead of \verb|integer| constants or, alternatively, explicitly convert \verb|integer| constants to \verb|double precision| by means of the \verb|dble| intrinsic function.

\begin{shaded}
\begin{small}
\begin{verbatim}
average= (value1 + value2) / 2d0       ! does not use an integer at all
average= (value1 + value2) / dble(2)   ! explicit type conversion
\end{verbatim}
\end{small}
\end{shaded}

It is often even better not to use any literal constants, leading to a code like

\begin{shaded}
\begin{small}
\begin{verbatim}
double precision, parameter:: TWO= 2.d0
! possibly other statements
average= (value1 + value2) / TWO
\end{verbatim}
\end{small}
\end{shaded}

Using uppercase names for constants is a widespread habit but this is a matter of style only.

\subsubsection{Continuation lines}

Source code lines should not exceed 80 characters (though some \software{Fortran} compilers support longer lines). If an expression does not fit on a single line, the ampersand (\verb|&|) must be used to indicate continuation lines. It is recommended to put the \verb|&| at the end of any unfinished line as in the following example:

\begin{shaded}
\begin{small}
\begin{verbatim}
a = term1 + term2 + &
    term3 + term4 + &
    term5
\end{verbatim}
\end{small}
\end{shaded}

Missing \verb|&| characters are a frequent cause of compile time errors sometimes being rather obscure.

\subsection{More information on \software{Fortran} programming}

The examples in Sect.~\ref{sec:advanced:fortran} may serve as a starting point. The website \url{http://fortranwiki.org/fortran/show/HomePage} is a good source of additional information, providing links to standard documents, books, etc.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Practical issues} \label{sec:practical}

\subsection{Managing tabular input data}

The tabular input data can be held in either plain text files or spreadsheets. The two alternatives have their own pros and cons as described below:

Spreadsheet software is specialized on displaying tabular data in a convenient way. Nevertheless, there are some practical issues. For example, spreadsheet programs allow for cell formatting. Formatting rules and automatisms often lead to unwanted results (e.g. in the case of logical columns). This also depends on the used format (e.g. 'xlsx' or 'odt'). As of now, R does not have native support for spreadsheets in 'odt' format. Conversion between 'odt' and 'xlsx' is possible, but the exact result seems to be unpredictable.

Delimited text files are much simpler in concept. They can be edited with any editor and platform dependence is a minor issue because line endings and character encodings are easy to change. Good programs provide powerful editing commands, e.g. using regular expressions, and they can highlight matching parenthesis. Text files are perfect for use with version control systems. Nevertheless, normal editors are unable to display tabular data in a nice way.

It is a good compromise to store the tabular data in delimited text files (e.g. separated by TAB or semicolon) and to open them either in a spreadsheet program or editor, depending on the actual task. Note that the conventional 'csv' is not recommended since mathematical expressions involving multi-argument functions and text descriptions may contain commas (hence, they need to be quoted). Using TAB-delimited text is probably the best option.

\end{document}

